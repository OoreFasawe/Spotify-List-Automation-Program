# -*- coding: utf-8 -*-
"""Spotify2

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/12e6Dho80tFCTQKjNGXqghPt_pUinL1Kn
"""

# install the dependencies we need we need here
!pip install spotipy

from pprint import pprint
import spotipy
from spotipy.oauth2 import SpotifyClientCredentials
import pandas as pd
sp = spotipy.Spotify(auth_manager=SpotifyClientCredentials(client_id="",
                                                           client_secret=""))

pd.set_option("display.max_rows", None, "display.max_columns", None) # allow pandas pring entire df

class hashabledict(dict):
    def __hash__(self):
        return hash(tuple(sorted(self.items())))

def get_artists_features_df(artist_urn):
  """
  Give an artists urn will look through thier 
  catalog and get the artist and track/album info of their features
  """
  features = []

  for album_type in ("album", "single"):
    for track in sp.artist_albums(artist_urn, album_type=album_type)["items"]:
      for artist in track["artists"]:
        artist_info = sp.artist(artist["id"])
        features.append({
          "genres": tuple(artist_info["genres"]),
          "followers": artist_info["followers"]["total"],
          "urn": artist_info["id"],
          "popularity": artist_info["popularity"],
          "name": artist_info["name"],
          # "track/album name": track["name"],
          "link": artist_info["external_urls"]["spotify"]
      })

  return pd.DataFrame(features)

def get_clean_related(urn):
  results = []
  for artist in sp.artist_related_artists(urn)["artists"]:
    results.append({
        "genres": tuple(artist["genres"]),
        "followers": artist["followers"]["total"],
        "urn": artist["id"],
        "popularity": artist["popularity"],
        "name": artist["name"],
        "link": artist["external_urls"]["spotify"]
    })
  return results

def get_starting_artist_urns(artists: list):
      results = []
      for artist_name in artists:
        search_results = sp.search(q='artist:' + artist_name, type='artist', limit=10)["artists"]["items"]
        search_results = sorted(search_results, key=lambda k: k['popularity'])
        results.append(search_results[-1]) #Â the most popular is most likely the match
      return results

def get_related_artists_df(artist_names: list):
    artist_urns = get_starting_artist_urns(artist_names)
    # get artists related to the starting aritsts form a new dict with search result artist id as the key
    related_artist_by_urn = {artist["id"]: get_clean_related(artist["id"]) for artist in artist_urns}
    # get related artists for every related artist
    nested_related_artist_by_urn = {}
    for urn in related_artist_by_urn.keys():
      relateds = related_artist_by_urn[urn]
      for artist in relateds:
        nested_related_artist_by_urn[artist["urn"]] = get_clean_related(artist["urn"])
    final_set_of_related_artists = set()
    for urn in nested_related_artist_by_urn.keys():
      final_set_of_related_artists.update([hashabledict(x) for x in nested_related_artist_by_urn[urn]])
    return pd.DataFrame(final_set_of_related_artists)

def get_artists_for_genres_df(genres: list):
  """
  returns a df similar to get_related_artists_df that contains artists that match the input genres
  """
  pass

get_clean_related("6RIJu05yhEIYskbVgxmk3R")

"""# **Analysis for festival line up**"""

starting_artists = ["Sam smith"]

df = get_related_artists_df(starting_artists)
df =df.set_index("name")
df["name"] = df.index
# df = df[df["name"]=="LADIPOE"]
# df.sort_values(by=["popularity", "followers"], inplace=True, ascending=False)
df

"""# Headliners.
Artists with over 700k followers and over 75 popularity
"""

headliners = df[(df["followers"] > 55151) ]
headliners["rank"]="Headliner"
# headliners = headliners.sample(n=2)
headliners

"""# A list.
Artists with over 500k followers and between 65-80 popularity
"""

a_list = df[(df["followers"] > 100000) & ((df["popularity"] >= 40) & (df["popularity"] < 60)) ]
a_list["rank"] = "A list"
a_list = a_list.sample(n=5)
a_list

"""# B list.
Artists with over 150k followers and between 60-75 popularity
"""

b_list = df[(df["followers"] > 50000) & (df["popularity"] >= 30) ]
b_list["rank"] = "B list"
b_list = b_list.sample(n=10)
b_list

"""#C list
Artists with over 100k followers and between 55-60 popularity
"""

c_list = df[(df["followers"] > 70000) & (df["popularity"] >= 40) ]
c_list["rank"] = "C list"
c_list = c_list.sample(n=5)
c_list

"""# D list.
Artists with over 12k followers and between 40-55 popularity
"""

d_list = df[(df["followers"] >=20000) & ((df["popularity"] >= 20)) ]
# d_list = d_list.sample(10)
d_list["rank"] = "D list"
d_list

# df = get_artists_features_df("46pWGuE3dSwY3bMMXGBvVS")
def get_artist_df(urns):
  """
  """
  artists = []
  for urn in urns:
    artist_info = sp.artist(artist_id=urn)
    artists.append({
          "genres": tuple(artist_info["genres"]),
          "followers": artist_info["followers"]["total"],
          "urn": artist_info["id"],
          "popularity": artist_info["popularity"],
          "name": artist_info["name"],
          "link": artist_info["external_urls"]["spotify"]
      })
  return pd.DataFrame(artists)

df

headliners.sort_values(by=["popularity", "followers"], inplace=True, ascending=False)
# headliners = df
# headliners["rank"]="Headliner"
# headliners = headliners.sample(n=2)

proposed_line_up = headliners
proposed_line_up = proposed_line_up.drop_duplicates(subset=['urn'], keep="first")
proposed_line_up.sort_values(by=["popularity", "followers"], inplace=True, ascending=False)
proposed_line_up["name"] = proposed_line_up.index

proposed_line_up
